"""
Utilidades y funciones de apoyo para GenomiX
Agente inteligente especializado en Biolog√≠a
"""

import re
import json
import logging
from typing import List, Dict, Any, Optional, Tuple
import unicodedata
from datetime import datetime

logger = logging.getLogger(__name__)

def format_species_info(species: Dict[str, Any]) -> str:
    """
    Formatear informaci√≥n de especies con estilo GenomiX
    
    Args:
        species: Diccionario con datos de la especie
        
    Returns:
        Texto formateado con informaci√≥n de la especie
    """
    try:
        # Informaci√≥n b√°sica
        name = species.get('name', 'Especie no identificada')
        scientific_name = species.get('scientific_name', 'N/A')
        confidence = species.get('confidence', 'N/A')
        
        # Taxonom√≠a
        kingdom = species.get('kingdom', 'N/A')
        phylum = species.get('phylum', 'N/A')
        class_name = species.get('class', 'N/A')
        order = species.get('order', 'N/A')
        family = species.get('family', 'N/A')
        
        # Caracter√≠sticas
        characteristics = species.get('characteristics', 'Sin descripci√≥n disponible')
        habitat = species.get('habitat', 'H√°bitat no especificado')
        behavior = species.get('behavior', 'Comportamiento no documentado')
        diet = species.get('diet', 'Dieta no especificada')
        size = species.get('size', 'Tama√±o no especificado')
        
        # Formatear con estilo GenomiX
        formatted_info = f"""
üß¨ **{name}** (*{scientific_name}*)
{'‚îÄ' * 50}

**üìä Clasificaci√≥n Taxon√≥mica**
‚îú‚îÄ Reino: {kingdom}
‚îú‚îÄ Filo: {phylum}  
‚îú‚îÄ Clase: {class_name}
‚îú‚îÄ Orden: {order}
‚îî‚îÄ Familia: {family}

**üî¨ Caracter√≠sticas Morfol√≥gicas**
{characteristics}

**üåç H√°bitat y Distribuci√≥n**
{habitat}

**‚ö° Comportamiento**
{behavior}

**üçΩÔ∏è Dieta**
{diet}

**üìè Dimensiones**
{size}

**üí° Confianza del An√°lisis GenomiX:** {confidence}%
"""
        
        return formatted_info.strip()
        
    except Exception as e:
        logger.error(f"Error formateando informaci√≥n de especie: {e}")
        return f"Error procesando informaci√≥n de {species.get('name', 'especie desconocida')}"

def extract_biological_concepts(text: str) -> List[str]:
    """
    Extraer conceptos biol√≥gicos clave de un texto
    
    Args:
        text: Texto del cual extraer conceptos
        
    Returns:
        Lista de conceptos biol√≥gicos identificados
    """
    # Diccionario de conceptos biol√≥gicos con patrones
    biological_patterns = {
        # Procesos celulares
        r'\b(?:mitosis|meiosis|citocinesis|apoptosis)\b': 'Divisi√≥n Celular',
        r'\b(?:fotos√≠ntesis|respiraci√≥n celular|gluc√≥lisis)\b': 'Metabolismo',
        r'\b(?:transcripci√≥n|traducci√≥n|replicaci√≥n)\b': 'Expresi√≥n G√©nica',
        
        # Mol√©culas biol√≥gicas
        r'\b(?:ADN|ARN|prote√≠na|enzima|ATP)\b': 'Mol√©culas Biol√≥gicas',
        r'\b(?:carbohidrato|l√≠pido|amino√°cido)\b': 'Biomol√©culas',
        
        # Gen√©tica
        r'\b(?:gen|genoma|cromosoma|alelo|mutaci√≥n)\b': 'Gen√©tica',
        r'\b(?:herencia|dominante|recesivo|fenotipo|genotipo)\b': 'Herencia',
        
        # Evoluci√≥n
        r'\b(?:evoluci√≥n|selecci√≥n natural|adaptaci√≥n|especiaci√≥n)\b': 'Evoluci√≥n',
        r'\b(?:ancestro com√∫n|filogenia|deriva gen√©tica)\b': 'Filogenia',
        
        # Ecolog√≠a
        r'\b(?:ecosistema|biodiversidad|nicho ecol√≥gico)\b': 'Ecolog√≠a',
        r'\b(?:cadena alimentaria|productor|consumidor|descomponedor)\b': 'Redes Tr√≥ficas',
        
        # Anatom√≠a y fisiolog√≠a
        r'\b(?:sistema nervioso|sistema circulatorio|homeostasis)\b': 'Fisiolog√≠a',
        r'\b(?:tejido|√≥rgano|c√©lula|organelo)\b': 'Anatom√≠a',
        
        # Taxonom√≠a
        r'\b(?:reino|filo|clase|orden|familia|g√©nero|especie)\b': 'Taxonom√≠a',
        r'\b(?:clasificaci√≥n|nomenclatura binomial)\b': 'Sistem√°tica'
    }
    
    concepts_found = []
    text_lower = text.lower()
    
    for pattern, category in biological_patterns.items():
        matches = re.findall(pattern, text_lower, re.IGNORECASE)
        if matches:
            concepts_found.extend([(match, category) for match in matches])
    
    # Remover duplicados manteniendo orden
    unique_concepts = []
    seen = set()
    
    for concept, category in concepts_found:
        if concept not in seen:
            unique_concepts.append(f"{concept.capitalize()} ({category})")
            seen.add(concept)
    
    return unique_concepts

def clean_biological_text(text: str) -> str:
    """
    Limpiar y normalizar texto biol√≥gico
    
    Args:
        text: Texto a limpiar
        
    Returns:
        Texto limpio y normalizado
    """
    if not text:
        return ""
    
    # Normalizar unicode
    text = unicodedata.normalize('NFKD', text)
    
    # Remover caracteres de control
    text = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', text)
    
    # Normalizar espacios
    text = re.sub(r'\s+', ' ', text)
    
    # Limpiar caracteres especiales pero mantener cient√≠ficos
    text = re.sub(r'[^\w\s\-\.\,\;\:\(\)\[\]¬∞‚Ä≤‚Ä≥Œ±Œ≤Œ≥Œ¥ŒµŒºœÄ]', '', text)
    
    return text.strip()

def validate_species_data(species_data: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """
    Validar estructura de datos de especies
    
    Args:
        species_data: Diccionario con datos de especie
        
    Returns:
        Tupla (es_v√°lido, lista_de_errores)
    """
    errors = []
    
    # Campos obligatorios
    required_fields = ['name', 'scientific_name', 'family']
    
    for field in required_fields:
        if not species_data.get(field):
            errors.append(f"Campo obligatorio faltante: {field}")
    
    # Validar nombre cient√≠fico (formato binomial b√°sico)
    scientific_name = species_data.get('scientific_name', '')
    if scientific_name and not re.match(r'^[A-Z][a-z]+ [a-z]+', scientific_name):
        errors.append("Nombre cient√≠fico no sigue nomenclatura binomial")
    
    # Validar taxonom√≠a
    taxonomic_ranks = ['kingdom', 'phylum', 'class', 'order', 'family']
    for rank in taxonomic_ranks:
        value = species_data.get(rank, '')
        if value and not isinstance(value, str):
            errors.append(f"Rango taxon√≥mico {rank} debe ser texto")
    
    return len(errors) == 0, errors

def generate_species_summary(species: Dict[str, Any]) -> str:
    """
    Generar resumen conciso de una especie
    
    Args:
        species: Datos de la especie
        
    Returns:
        Resumen formateado
    """
    name = species.get('name', 'Especie no identificada')
    scientific_name = species.get('scientific_name', '')
    family = species.get('family', 'Familia desconocida')
    characteristics = species.get('characteristics', '')[:100] + "..." if len(species.get('characteristics', '')) > 100 else species.get('characteristics', '')
    
    summary = f"**{name}**"
    if scientific_name:
        summary += f" (*{scientific_name}*)"
    
    summary += f"\nüìö {family}"
    
    if characteristics:
        summary += f"\nüîç {characteristics}"
    
    return summary

def format_concept_explanation(concept: Dict[str, Any]) -> str:
    """
    Formatear explicaci√≥n de concepto biol√≥gico
    
    Args:
        concept: Datos del concepto
        
    Returns:
        Explicaci√≥n formateada con estilo GenomiX
    """
    try:
        name = concept.get('name', 'Concepto sin nombre')
        category = concept.get('category', 'Sin categor√≠a')
        definition = concept.get('definition', 'Sin definici√≥n')
        description = concept.get('description', '')
        importance = concept.get('importance', '')
        examples = concept.get('examples', [])
        related_concepts = concept.get('related_concepts', [])
        
        formatted_explanation = f"""
üß¨ **{name}**
üìÇ *Categor√≠a: {category}*
{'‚îÄ' * 40}

**üî¨ Definici√≥n Cient√≠fica**
{definition}

"""
        
        if description:
            formatted_explanation += f"""**‚ö° Descripci√≥n Detallada**
{description}

"""
        
        if importance:
            formatted_explanation += f"""**üéØ Importancia Biol√≥gica**
{importance}

"""
        
        if examples:
            formatted_explanation += f"""**üìä Ejemplos Pr√°cticos**
{chr(10).join([f"‚Ä¢ {example}" for example in examples])}

"""
        
        if related_concepts:
            formatted_explanation += f"""**üîó Conceptos Relacionados**
{', '.join(related_concepts)}
"""
        
        return formatted_explanation.strip()
        
    except Exception as e:
        logger.error(f"Error formateando explicaci√≥n de concepto: {e}")
        return f"Error procesando concepto {concept.get('name', 'desconocido')}"

def create_taxonomic_hierarchy(species_data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Crear jerarqu√≠a taxon√≥mica a partir de datos de especies
    
    Args:
        species_data: Lista de especies
        
    Returns:
        Diccionario con jerarqu√≠a taxon√≥mica
    """
    hierarchy = {}
    
    for species in species_data:
        # Construir path taxon√≥mico
        kingdom = species.get('kingdom', 'Unknown')
        phylum = species.get('phylum', 'Unknown')
        class_name = species.get('class', 'Unknown')
        order = species.get('order', 'Unknown')
        family = species.get('family', 'Unknown')
        
        # Crear estructura jer√°rquica
        if kingdom not in hierarchy:
            hierarchy[kingdom] = {}
        
        if phylum not in hierarchy[kingdom]:
            hierarchy[kingdom][phylum] = {}
        
        if class_name not in hierarchy[kingdom][phylum]:
            hierarchy[kingdom][phylum][class_name] = {}
        
        if order not in hierarchy[kingdom][phylum][class_name]:
            hierarchy[kingdom][phylum][class_name][order] = {}
        
        if family not in hierarchy[kingdom][phylum][class_name][order]:
            hierarchy[kingdom][phylum][class_name][order][family] = []
        
        # Agregar especie a la familia
        hierarchy[kingdom][phylum][class_name][order][family].append({
            'name': species.get('name', 'Sin nombre'),
            'scientific_name': species.get('scientific_name', 'Sin nombre cient√≠fico')
        })
    
    return hierarchy

def generate_genomix_response_template(query_type: str) -> str:
    """
    Generar plantilla de respuesta seg√∫n el tipo de consulta
    
    Args:
        query_type: Tipo de consulta ('species', 'concept', 'process', 'general')
        
    Returns:
        Plantilla de respuesta con formato GenomiX
    """
    templates = {
        'species': """
üß¨ **An√°lisis de Especies GenomiX**

**üîç Identificaci√≥n Sistem√°tica**
[Informaci√≥n de identificaci√≥n]

**üìä Clasificaci√≥n Taxon√≥mica**
[Jerarqu√≠a taxon√≥mica]

**üî¨ Caracter√≠sticas Distintivas**
[Descripci√≥n morfol√≥gica y funcional]

**üí° Perspectiva GenomiX**
[Insights adicionales y conexiones]
""",
        
        'concept': """
üß¨ **Explicaci√≥n Conceptual GenomiX**

**üî¨ Definici√≥n Cient√≠fica**
[Definici√≥n precisa]

**‚öôÔ∏è Mecanismo Biol√≥gico**
[C√≥mo funciona el proceso/concepto]

**üéØ Importancia y Aplicaciones**
[Relevancia biol√≥gica y aplicaciones]

**üîó Conexiones Biol√≥gicas**
[Relaci√≥n con otros conceptos]

**üí° Perspectiva GenomiX**
[Insights tecnol√≥gicos y futuros]
""",
        
        'process': """
üß¨ **An√°lisis de Proceso GenomiX**

**‚ö° Descripci√≥n del Proceso**
[Descripci√≥n general]

**üîÑ Mec√°nica Molecular**
[Pasos detallados del proceso]

**üìä Regulaci√≥n y Control**
[Mecanismos de control]

**üî¨ Metodolog√≠a de Estudio**
[C√≥mo se estudia este proceso]

**üí° Aplicaciones GenomiX**
[Aplicaciones biotecnol√≥gicas]
""",
        
        'general': """
üß¨ **Respuesta GenomiX**

[Contenido de respuesta adaptado al contexto]

**üí° Insight GenomiX**
[Perspectiva √∫nica o conexi√≥n interdisciplinaria]

*"Descifrando la vida, gen por gen"*
"""
    }
    
    return templates.get(query_type, templates['general'])

def log_genomix_interaction(query: str, response: str, success: bool = True):
    """
    Registrar interacciones de GenomiX para an√°lisis
    
    Args:
        query: Consulta del usuario
        response: Respuesta de GenomiX
        success: Si la interacci√≥n fue exitosa
    """
    try:
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'query': query[:100] + "..." if len(query) > 100 else query,
            'response_length': len(response),
            'success': success,
            'query_type': classify_query_type(query)
        }
        
        logger.info(f"GenomiX Interaction: {json.dumps(log_entry)}")
        
    except Exception as e:
        logger.error(f"Error logging GenomiX interaction: {e}")

def classify_query_type(query: str) -> str:
    """
    Clasificar tipo de consulta para optimizar respuesta
    
    Args:
        query: Consulta del usuario
        
    Returns:
        Tipo de consulta identificado
    """
    query_lower = query.lower()
    
    # Patrones para identificaci√≥n de especies
    species_indicators = [
        'identifica', 'qu√© animal', 'qu√© planta', 'describe', 'caracter√≠sticas',
        'peque√±o', 'grande', 'vive en', 'h√°bitat', 'comportamiento'
    ]
    
    # Patrones para conceptos
    concept_indicators = [
        'qu√© es', 'explica', 'define', 'c√≥mo funciona', 'proceso de',
        'fotos√≠ntesis', 'respiraci√≥n', 'mitosis', 'evoluci√≥n', 'gen'
    ]
    
    # Patrones para procesos
    process_indicators = [
        'paso a paso', 'etapas', 'fases', 'mecanismo', 'ciclo',
        'replicaci√≥n', 'transcripci√≥n', 'traducci√≥n'
    ]
    
    # Patrones para taxonom√≠a
    taxonomy_indicators = [
        'clasificaci√≥n', 'taxonom√≠a', 'reino', 'filo', 'familia',
        'nombre cient√≠fico', 'sistem√°tica'
    ]
    
    if any(indicator in query_lower for indicator in species_indicators):
        return 'species'
    elif any(indicator in query_lower for indicator in process_indicators):
        return 'process'
    elif any(indicator in query_lower for indicator in taxonomy_indicators):
        return 'taxonomy'
    elif any(indicator in query_lower for indicator in concept_indicators):
        return 'concept'
    else:
        return 'general'

def format_error_message(error: Exception, context: str = "") -> str:
    """
    Formatear mensajes de error con estilo GenomiX
    
    Args:
        error: Excepci√≥n capturada
        context: Contexto del error
        
    Returns:
        Mensaje de error formateado
    """
    error_messages = {
        "connection": """
üî¨ **GenomiX - Problema de Conexi√≥n**

Los sistemas GenomiX est√°n experimentando dificultades de conectividad. Como un organismo adapt√°ndose a condiciones adversas, estamos reconfigurando nuestros sistemas.

üí° **Mientras tanto, puedes:**
‚Ä¢ Verificar tu conexi√≥n a internet
‚Ä¢ Intentar tu consulta nuevamente en unos momentos
‚Ä¢ Reformular tu pregunta de manera m√°s espec√≠fica

*Los sistemas biol√≥gicos tambi√©n enfrentan disrupciones, pero siempre encuentran formas de adaptarse.*
""",
        
        "api_key": """
üî¨ **GenomiX - Configuraci√≥n de API**

Como un organismo necesita nutrientes para funcionar, GenomiX requiere una API key v√°lida para acceder a sus sistemas avanzados.

üí° **Soluci√≥n:**
‚Ä¢ Obt√©n una API key gratuita en console.groq.com
‚Ä¢ Verifica que la clave est√© correctamente ingresada
‚Ä¢ Aseg√∫rate de tener conexi√≥n a internet

*La precisi√≥n en la configuraci√≥n es tan importante como la precisi√≥n en la ciencia.*
""",
        
        "general": f"""
üî¨ **GenomiX - An√°lisis Temporal No Disponible**

Los sistemas GenomiX han encontrado una situaci√≥n inesperada durante el an√°lisis{': ' + context if context else ''}.

üí° **Como un cient√≠fico experimentado, GenomiX sugiere:**
‚Ä¢ Reformular la consulta con t√©rminos m√°s espec√≠ficos
‚Ä¢ Proporcionar m√°s contexto biol√≥gico
‚Ä¢ Intentar la consulta nuevamente

*En la ciencia, cada obst√°culo es una oportunidad para refinar nuestro enfoque.*

Error t√©cnico: {str(error)}
"""
    }
    
    # Determinar tipo de error
    if "connection" in str(error).lower() or "network" in str(error).lower():
        return error_messages["connection"]
    elif "api" in str(error).lower() or "key" in str(error).lower():
        return error_messages["api_key"]
    else:
        return error_messages["general"]
